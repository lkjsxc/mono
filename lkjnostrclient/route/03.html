<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple Nostr Client</title>
    <style>
        :root {
            --bg-color: #121212;
            --fg-color: #e0e0e0;
            --panel-bg: #1e1e1e;
            --border-color: #333;
            --accent-color: #007bff;
            --accent-hover: #0056b3;
            --error-color: #d9534f;
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }
        body {
            font-family: var(--font-family);
            background-color: var(--bg-color);
            color: var(--fg-color);
            margin: 0;
            padding: 1rem;
            line-height: 1.6;
        }
        #app-container {
            display: flex;
            gap: 1rem;
            height: calc(100vh - 2rem);
            max-width: 1200px;
            margin: 0 auto;
        }
        #left-panel, #right-panel {
            background-color: var(--panel-bg);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 1rem;
            display: flex;
            flex-direction: column;
        }
        #left-panel {
            flex: 1;
            min-width: 300px;
        }
        #right-panel {
            flex: 2;
            overflow-y: hidden;
        }
        h2 {
            margin-top: 0;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
        }
        label {
            margin-top: 1rem;
            margin-bottom: 0.25rem;
            font-weight: bold;
            font-size: 0.9rem;
        }
        textarea {
            width: calc(100% - 20px);
            padding: 10px;
            background-color: var(--bg-color);
            color: var(--fg-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            resize: vertical;
            font-family: 'Courier New', Courier, monospace;
        }
        #private-key-input {
            height: 60px;
        }
        #note-composer {
            height: 120px;
            flex-grow: 1;
        }
        button {
            padding: 0.75rem 1rem;
            border: none;
            border-radius: 4px;
            background-color: var(--accent-color);
            color: white;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
            margin-top: 1rem;
        }
        button:hover {
            background-color: var(--accent-hover);
        }
        button:disabled {
            background-color: #555;
            cursor: not-allowed;
        }
        #timeline-container {
            flex-grow: 1;
            overflow-y: auto;
            padding-right: 10px;
        }
        .note {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            margin-bottom: 1rem;
            word-wrap: break-word;
        }
        .note-author {
            font-size: 0.8rem;
            color: #aaa;
            font-family: 'Courier New', Courier, monospace;
            margin-bottom: 0.5rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .note-content {
            white-space: pre-wrap;
        }
    </style>
</head>
<body>

    <div id="app-container">
        <div id="left-panel">
            <h2>Controls</h2>
            <button id="generate-keys-btn">Generate New Keys</button>

            <label for="private-key-input">Private Key (nsec)</label>
            <textarea id="private-key-input" placeholder="Enter your nsec... key here"></textarea>

            <label for="note-composer">Compose Note</label>
            <textarea id="note-composer" placeholder="What's on your mind?"></textarea>

            <button id="post-btn">Post</button>
        </div>
        <div id="right-panel">
            <h2>Timeline (Kind 1 Notes)</h2>
            <div id="timeline-container"></div>
        </div>
    </div>

    <script type="module">
        import * as NostrTools from 'https://esm.sh/nostr-tools@2.1.4';

        // --- Step 1: Core Constants & State ---

        const RELAY_URLS = [
            'wss://relay.damus.io',
            'wss://relay.snort.social',
            'wss://nos.lol',
            'wss://relay.primal.net',
            'wss://nostr.wine'
        ];

        // The application state is managed within the init() scope.
        // It is not a global mutable variable, adhering to functional principles.

        // --- Step 2: Pure Nostr Logic Functions (Result-based) ---

        /**
         * Generates a new Nostr key pair.
         * @returns {{ok: true, value: {sk: string, pk: string}}} A Result object with the hex private and public keys.
         */
        const generateKeys = () => {
            const sk = NostrTools.generatePrivateKey();
            const pk = NostrTools.getPublicKey(sk);
            return { ok: true, value: { sk, pk } };
        };

        /**
         * Decodes an nsec private key into its hex representation.
         * @param {string} nsec - The nsec private key string.
         * @returns {Result<{sk: string, pk: string}, string>} A Result object.
         */
        const decodeNsec = (nsec) => {
            if (!nsec || !nsec.startsWith('nsec1')) {
                return { ok: false, error: 'Invalid nsec format. It must start with "nsec1".' };
            }
            try {
                const { type, data } = NostrTools.nip19.decode(nsec);
                if (type !== 'nsec') {
                    return { ok: false, error: 'Key is not an nsec private key.' };
                }
                const pk = NostrTools.getPublicKey(data);
                return { ok: true, value: { sk: data, pk } };
            } catch (e) {
                return { ok: false, error: `Failed to decode private key: ${e.message}` };
            }
        };

        /**
         * Creates and signs a kind 1 (text note) event.
         * @param {string} privateKeyHex - The user's private key in hex format.
         * @param {string} content - The content of the note.
         * @returns {Result<NostrTools.Event, string>} A Result object containing the signed event.
         */
        const createNoteEvent = (privateKeyHex, content) => {
            if (!content.trim()) {
                return { ok: false, error: 'Note content cannot be empty.' };
            }
            try {
                const publicKey = NostrTools.getPublicKey(privateKeyHex);
                const eventTemplate = {
                    kind: 1,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [],
                    content: content,
                    pubkey: publicKey,
                };
                const id = NostrTools.getEventHash(eventTemplate);
                const sig = NostrTools.signEvent(eventTemplate, privateKeyHex);
                const signedEvent = { ...eventTemplate, id, sig };
                return { ok: true, value: signedEvent };
            } catch (e) {
                return { ok: false, error: `Failed to create note event: ${e.message}` };
            }
        };
        
        /**
         * Validates the structure and hash of a Nostr event.
         * @param {NostrTools.Event} event - The event to validate.
         * @returns {Result<boolean, string>}
         */
        const validateEvent = (event) => {
            if (!NostrTools.validateEvent(event)) {
                return { ok: false, error: 'Event validation failed (invalid structure or hash).' };
            }
            return { ok: true, value: true };
        };

        /**
         * Verifies the signature of a Nostr event.
         * @param {NostrTools.Event} event - The event to verify.
         * @returns {Result<boolean, string>}
         */
        const verifySignature = (event) => {
            if (!NostrTools.verifySignature(event)) {
                return { ok: false, error: 'Event signature verification failed.' };
            }
            return { ok: true, value: true };
        };

        // --- Step 3: DOM Interaction Functions ---

        const getElement = (id) => document.getElementById(id);

        /**
         * Displays an error message to the user.
         * @param {string} message - The error message.
         */
        const displayError = (message) => {
            console.error(message);
            alert(message);
        };

        /**
         * Creates an HTML element for a single note.
         * @param {object} note - A note object with content and pubkey.
         * @returns {HTMLElement} The rendered note element.
         */
        const createNoteElement = (note) => {
            const noteDiv = document.createElement('div');
            noteDiv.className = 'note';
            
            const authorDiv = document.createElement('div');
            authorDiv.className = 'note-author';
            const npub = NostrTools.nip19.npubEncode(note.pubkey);
            authorDiv.textContent = `Author: ${npub.slice(0, 16)}...${npub.slice(-4)}`;
            
            const contentDiv = document.createElement('div');
            contentDiv.className = 'note-content';
            contentDiv.textContent = note.content;

            noteDiv.appendChild(authorDiv);
            noteDiv.appendChild(contentDiv);
            return noteDiv;
        };
        
        /**
         * Renders the entire timeline of notes.
         * @param {HTMLElement} container - The DOM element to render into.
         * @param {Array<object>} notes - An array of note objects.
         */
        const renderTimeline = (container, notes) => {
            container.innerHTML = '';
            const sortedNotes = [...notes].sort((a, b) => b.created_at - a.created_at);
            sortedNotes.forEach(note => {
                const noteElement = createNoteElement(note);
                container.appendChild(noteElement);
            });
        };

        /**
         * Sets the loading state of a button.
         * @param {HTMLButtonElement} button - The button element.
         * @param {boolean} isLoading - The loading state.
         */
        const setButtonLoading = (button, isLoading) => {
            button.disabled = isLoading;
            button.textContent = isLoading ? '...' : button.dataset.originalText;
        };

        // --- Step 4: Main Application Logic ---

        /**
         * Connects to relays and subscribes to events.
         * @param {Array<string>} relays - Array of relay URLs.
         * @param {(event: NostrTools.Event) => void} onEventCallback - Callback for new events.
         * @returns {NostrTools.SimplePool} The relay pool instance.
         */
        const connectAndSubscribe = (relays, onEventCallback) => {
            const pool = new NostrTools.SimplePool();

            const sub = pool.sub(
                relays,
                [{ kinds: [1], limit: 50 }]
            );

            sub.on('event', event => {
                const isValid = validateEvent(event);
                if (!isValid.ok) {
                    console.warn(isValid.error, event);
                    return;
                }
                const isVerified = verifySignature(event);
                if (!isVerified.ok) {
                    console.warn(isVerified.error, event);
                    return;
                }
                onEventCallback(event);
            });

            console.log(`Connected to and subscribed on ${relays.length} relays.`);
            return pool;
        };

        /**
         * Publishes an event to the relays.
         * @param {NostrTools.SimplePool} pool - The relay pool.
         * @param {NostrTools.Event} event - The event to publish.
         */
        const publishEvent = async (pool, event) => {
            const pubs = pool.publish(RELAY_URLS, event);
            // Nostr-tools SimplePool publish returns an array of promises/callbacks
            // For this simple client, we fire and forget, but log success.
            pubs.on('ok', (relay) => {
              console.log(`Event published successfully to ${relay}`);
            });
            pubs.on('failed', (relay) => {
              console.error(`Failed to publish event to ${relay}`);
            });
        };

        /**
         * Initializes the application, sets up state and event handlers.
         */
        const init = () => {
            let appState = {
                notes: [],
                pool: null,
            };

            // Get DOM Elements
            const generateBtn = getElement('generate-keys-btn');
            const postBtn = getElement('post-btn');
            const privateKeyInput = getElement('private-key-input');
            const noteComposer = getElement('note-composer');
            const timelineContainer = getElement('timeline-container');

            // Store original button text for loading states
            postBtn.dataset.originalText = postBtn.textContent;

            // --- State Update and Render Logic ---
            const updateStateAndRender = (newEvent) => {
                const noteExists = appState.notes.some(note => note.id === newEvent.id);
                if (!noteExists) {
                    const newNote = {
                        id: newEvent.id,
                        pubkey: newEvent.pubkey,
                        content: newEvent.content,
                        created_at: newEvent.created_at,
                    };
                    const newNotes = [newNote, ...appState.notes].slice(0, 100);
                    appState = { ...appState, notes: newNotes };
                    renderTimeline(timelineContainer, appState.notes);
                }
            };
            
            // --- Event Handlers ---
            const handleGenerateKeys = () => {
                const result = generateKeys();
                if (result.ok) {
                    const nsec = NostrTools.nip19.nsecEncode(result.value.sk);
                    privateKeyInput.value = nsec;
                    console.log("New Keys Generated. Public key (npub):", NostrTools.nip19.npubEncode(result.value.pk));
                }
            };

            const handlePostNote = async () => {
                setButtonLoading(postBtn, true);
                
                const nsec = privateKeyInput.value;
                const content = noteComposer.value;

                const decodeResult = decodeNsec(nsec);
                if (!decodeResult.ok) {
                    displayError(decodeResult.error);
                    setButtonLoading(postBtn, false);
                    return;
                }
                
                const createEventResult = createNoteEvent(decodeResult.value.sk, content);
                if (!createEventResult.ok) {
                    displayError(createEventResult.error);
                    setButtonLoading(postBtn, false);
                    return;
                }

                const signedEvent = createEventResult.value;
                console.log('Publishing event:', signedEvent);
                await publishEvent(appState.pool, signedEvent);

                noteComposer.value = ''; // Clear composer on success
                setButtonLoading(postBtn, false);
                alert('Note sent to relays for publishing!');
            };

            // --- Setup ---
            generateBtn.addEventListener('click', handleGenerateKeys);
            postBtn.addEventListener('click', handlePostNote);

            // Connect to relays and start listening
            appState.pool = connectAndSubscribe(RELAY_URLS, updateStateAndRender);
        };
        
        // --- Run Application ---
        // The script is at the end of the body, so the DOM is ready.
        init();

    </script>
</body>
</html>