<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Simple FP Nostr Client (Private Key)</title>
    <!-- Core Library Import -->
    <script src="https://unpkg.com/nostr-tools@2.1.3/lib/nostr.bundle.js"></script>
    <style>
        /* CSS Styling */
        :root {
            --bg-color: #121212;
            --surface-color: #1e1e1e;
            --primary-color: #bb86fc;
            --secondary-color: #03dac6;
            --text-color: #e0e0e0;
            --error-color: #cf6679;
            --border-color: #333;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            line-height: 1.6;
        }

        #app-container {
            display: flex;
            height: 100vh;
        }

        .column {
            flex: 1;
            padding: 1.5rem;
            display: flex;
            flex-direction: column;
            gap: 1.5rem;
        }

        #post-section {
            border-right: 1px solid var(--border-color);
        }

        h1, h2 {
            color: var(--primary-color);
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 0.5rem;
            margin-top: 0;
        }
        
        .form-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        label {
            font-weight: bold;
            color: var(--secondary-color);
        }

        #private-key-input {
            width: 100%;
            background-color: var(--surface-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.75rem;
            font-size: 1rem;
            font-family: monospace;
        }
        
        .key-actions {
            display: flex;
            gap: 1rem;
        }

        #post-textarea {
            width: 100%;
            height: 150px;
            background-color: var(--surface-color);
            color: var(--text-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 0.75rem;
            font-size: 1rem;
            resize: vertical;
        }

        .button {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 4px;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            transition: background-color 0.2s;
        }
        
        #generate-keys-button {
            background-color: var(--secondary-color);
            color: var(--bg-color);
        }
        
        #post-button {
            background-color: var(--primary-color);
            color: var(--bg-color);
        }

        .button:disabled {
            background-color: var(--border-color);
            cursor: not-allowed;
        }

        #timeline-feed {
            flex-grow: 1;
            overflow-y: auto;
            display: flex;
            flex-direction: column-reverse; /* New notes appear at the top */
        }
        
        #timeline-container {
            display: flex;
            flex-direction: column;
            gap: 1rem;
        }

        .note-card {
            background-color: var(--surface-color);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            padding: 1rem;
            word-wrap: break-word;
        }

        .note-author {
            font-weight: bold;
            color: var(--secondary-color);
            font-family: monospace;
            font-size: 0.85rem;
            margin-bottom: 0.5rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        .note-content {
            white-space: pre-wrap;
        }
        
        #status-bar {
            position: fixed;
            bottom: 0;
            left: 0;
            width: 100%;
            padding: 0.5rem;
            background-color: var(--surface-color);
            text-align: center;
            font-size: 0.9rem;
            border-top: 1px solid var(--border-color);
            z-index: 10;
        }

        .status-error {
            color: var(--error-color);
            font-weight: bold;
        }
        .status-success {
            color: var(--secondary-color);
        }
    </style>
</head>
<body>
    <div id="app-container">
        <section id="post-section" class="column">
            <div>
                <h1>Login</h1>
                <div class="form-group">
                    <label for="private-key-input">Private Key (nsec or hex)</label>
                    <input type="password" id="private-key-input" placeholder="Enter your private key to login">
                    <div class="key-actions">
                        <button id="generate-keys-button" class="button">Generate New Keys</button>
                    </div>
                </div>
            </div>
            
            <div>
                <h1>Post a Note</h1>
                <div class="form-group">
                    <textarea id="post-textarea" placeholder="What's on your mind?"></textarea>
                    <button id="post-button" class="button" disabled>Login to Post</button>
                </div>
            </div>

        </section>
        <section id="timeline-section" class="column">
            <h1>Timeline</h1>
            <div id="timeline-feed">
                <div id="timeline-container"></div>
            </div>
        </section>
    </div>
    <div id="status-bar">Please enter a private key or generate a new one.</div>

    <script>
        // Ensure nostr-tools is available
        const nostr = window.nostrTools;

        /**
         * =================================================================
         * Core Utility & Error Handling Functions
         * =================================================================
         */

        const Ok = (value) => ({ ok: value, err: null });
        const Err = (error) => ({ ok: null, err: error });
        const isOk = (result) => result.err === null;
        const isErr = (result) => result.err !== null;
        
        /**
         * =================================================================
         * Nostr Functions (Pure Logic)
         * =================================================================
         */

        /**
         * Generates a new Nostr key pair. (Pure)
         * @returns {{sk: string, pk: string}} The new key pair (hex format).
         */
        const generateNewKeys = () => {
            const sk = nostr.generatePrivateKey();
            const pk = nostr.getPublicKey(sk);
            return { sk, pk };
        };
        
        /**
         * Decodes a private key (nsec or hex) and derives the public key. (Pure)
         * @param {string} keyInput - The private key string (nsec or hex).
         * @returns {{ok: {sk: string, pk: string}, err: Error | null}}
         */
        const getKeysFromInput = (keyInput) => {
            try {
                let sk = keyInput.trim();
                if (keyInput.startsWith('nsec')) {
                    const decodeResult = nostr.nip19.decode(keyInput);
                    if (decodeResult.type !== 'nsec' || !decodeResult.data) {
                        return Err(new Error('Invalid nsec private key format.'));
                    }
                    sk = decodeResult.data;
                }
                
                if (!/^[a-f0-9]{64}$/.test(sk)) {
                    return Err(new Error('Private key must be a 64-character hex string.'));
                }
                
                const pk = nostr.getPublicKey(sk);
                return Ok({ sk, pk });
            } catch (error) {
                return Err(new Error('Could not process private key.'));
            }
        };

        /**
         * Creates and finalizes a kind 1 note event using a private key. (Pure)
         * @param {string} content - The content of the note.
         * @param {string} sk - The user's private key (hex).
         * @returns {{ok: object, err: Error | null}} A Result containing the signed event.
         */
        const createAndSignNote = (content, sk) => {
            if (!content || typeof content !== 'string' || content.trim() === '') {
                return Err(new Error('Note content cannot be empty.'));
            }
            try {
                const eventTemplate = {
                    kind: 1,
                    created_at: Math.floor(Date.now() / 1000),
                    tags: [],
                    content: content.trim(),
                };
                // nostr.finalizeEvent handles getting pubkey, hashing, signing, and adding the id.
                const signedEvent = nostr.finalizeEvent(eventTemplate, sk);
                return Ok(signedEvent);
            } catch (error) {
                return Err(new Error(`Failed to sign event: ${error.message}`));
            }
        };
        
        /**
         * =================================================================
         * DOM Manipulation Functions
         * =================================================================
         */

        const createNoteElement = (noteEvent) => {
            const card = document.createElement('div');
            card.className = 'note-card';

            const author = document.createElement('div');
            author.className = 'note-author';
            const npub = nostr.nip19.npubEncode(noteEvent.pubkey);
            author.textContent = `${npub.slice(0, 12)}...${npub.slice(-4)}`;
            
            const content = document.createElement('p');
            content.className = 'note-content';
            content.textContent = noteEvent.content;

            card.appendChild(author);
            card.appendChild(content);
            return card;
        };

        const prependToTimeline = (element) => {
            const timeline = document.getElementById('timeline-container');
            if (timeline) {
                timeline.prepend(element);
            }
        };
        
        const displayStatus = (message, type = 'info') => {
            const statusBar = document.getElementById('status-bar');
            if (statusBar) {
                statusBar.textContent = message;
                statusBar.className = `status-${type}`;
            }
            if (type === 'error') console.error(message);
            else console.log(message);
        };

        /**
         * =================================================================
         * Side-Effect Functions (Interacting with the "World")
         * =================================================================
         */

        const connectToRelay = (url) => new Promise((resolve) => {
            try {
                const relay = nostr.relayInit(url);
                relay.on('connect', () => {
                    console.log(`Connected to ${relay.url}`);
                    resolve(Ok(relay))
                });
                relay.on('error', () => {
                    console.error(`Failed to connect to ${url}`);
                    resolve(Err(new Error(`Failed to connect to ${url}`)))
                });
                relay.connect();
            } catch (error) {
                resolve(Err(new Error(`Relay connection error for ${url}: ${error.message}`)));
            }
        });
        
        const publishToRelays = async (relays, signedEvent) => {
            const promises = relays.map(relay => new Promise((resolve, reject) => {
                const pub = relay.publish(signedEvent);
                pub.on('ok', () => resolve(Ok(relay.url)));
                pub.on('failed', (reason) => reject(Err(`Failed to publish to ${relay.url}: ${reason}`)));
                setTimeout(() => reject(Err(`Timeout publishing to ${relay.url}`)), 3000);
            }));

            const results = await Promise.allSettled(promises);
            const successes = results.filter(r => r.status === 'fulfilled' && isOk(r.value));
            
            if (successes.length > 0) {
                return Ok(successes.length);
            } else {
                const firstError = results.find(r => r.status === 'rejected')?.reason?.err || new Error('Publishing failed on all relays.');
                return Err(firstError);
            }
        };

        const subscribeToNotes = (relay, filters, onNoteCallback) => {
            console.log(`Subscribing to ${relay.url}`);
            const sub = relay.sub(filters);
            sub.on('event', onNoteCallback);
            sub.on('eose', () => console.log(`Initial event sync complete for ${relay.url}`));
            return Ok(sub);
        };


        /**
         * =================================================================
         * Application Main Logic
         * =================================================================
         */
        
        document.addEventListener('DOMContentLoaded', () => {
            const appState = {
                keys: null, // Will hold {sk, pk}
                relays: [],
                seenEventIds: new Set(),
            };

            const postButton = document.getElementById('post-button');
            const postTextarea = document.getElementById('post-textarea');
            const pkeyInput = document.getElementById('private-key-input');
            const generateButton = document.getElementById('generate-keys-button');

            const RELAY_URLS = ['wss://relay.damus.io', 'wss://relay.snort.social', 'wss://nostr.wine', 'wss://relay.primal.net'];

            const login = (keyInput) => {
                const keysResult = getKeysFromInput(keyInput);
                if (isErr(keysResult)) {
                    displayStatus(keysResult.err.message, 'error');
                    appState.keys = null;
                    postButton.disabled = true;
                    return;
                }

                appState.keys = keysResult.ok;
                postButton.disabled = false;
                const npub = nostr.nip19.npubEncode(appState.keys.pk);
                displayStatus(`Logged in as: ${npub.slice(0, 12)}...`, 'success');
            };

            const handleGenerateKeys = () => {
                const newKeys = generateNewKeys();
                const nsec = nostr.nip19.nsecEncode(newKeys.sk);
                pkeyInput.value = nsec;
                login(nsec);
                alert(`New keys generated and logged in!\n\nPublic Key (npub):\n${nostr.nip19.npubEncode(newKeys.pk)}\n\nPrivate Key (nsec):\n${nsec}\n\nIMPORTANT: Save your private key securely! It is shown here once and cannot be recovered.`);
            };

            const handlePost = async () => {
                if (!appState.keys) {
                    displayStatus('Cannot post. You are not logged in.', 'error');
                    return;
                }
                
                postButton.disabled = true;
                displayStatus('Signing and publishing note...', 'info');
                
                const signedResult = createAndSignNote(postTextarea.value, appState.keys.sk);
                if (isErr(signedResult)) {
                    displayStatus(signedResult.err.message, 'error');
                    postButton.disabled = false;
                    return;
                }
                
                const publishResult = await publishToRelays(appState.relays, signedResult.ok);
                if (isErr(publishResult)) {
                    displayStatus(publishResult.err.message, 'error');
                } else {
                    displayStatus(`Note published successfully to ${publishResult.ok} relay(s)!`, 'success');
                    postTextarea.value = '';
                }
                
                postButton.disabled = false;
            };

            const main = async () => {
                generateButton.addEventListener('click', handleGenerateKeys);
                pkeyInput.addEventListener('input', (e) => login(e.target.value));
                postButton.addEventListener('click', handlePost);

                displayStatus('Connecting to relays...', 'info');
                const connectionResults = await Promise.all(RELAY_URLS.map(connectToRelay));
                appState.relays = connectionResults.filter(isOk).map(result => result.ok);
                
                const failedCount = connectionResults.length - appState.relays.length;
                const successCount = appState.relays.length;

                if (successCount === 0) {
                    displayStatus('Failed to connect to any relays. Timeline will not update.', 'error');
                    return;
                }
                
                const onNote = (event) => {
                    if (!appState.seenEventIds.has(event.id)) {
                        appState.seenEventIds.add(event.id);
                        const noteElement = createNoteElement(event);
                        prependToTimeline(noteElement);
                    }
                };
                
                const filters = [{ kinds: [1], limit: 50 }]; // Increased limit for better initial load
                appState.relays.forEach(relay => subscribeToNotes(relay, filters, onNote));
                
                // Update status after subscriptions are set up
                if (!appState.keys) {
                    displayStatus(`Connected to ${successCount} relays. ${failedCount > 0 ? `(${failedCount} failed)` : ''} Please login.`, 'info');
                }
            };

            main();
        });
    </script>
</body>
</html>