# lkjsxcnext

Next.js、Prisma、NextAuthで構築された、メモ (EN: Memo) 管理Webアプリケーションです。ユーザー認証、公開/非公開メモの可視性、ポーリングによるリアルタイム更新、競合解決機能を備えた堅牢な自動保存機能を特徴としています。

## 目次

## 機能

-   **Google認証:** NextAuth.jsとGoogleプロバイダを使用した安全なサインイン/サインアップ。
-   **グループ機能:**
    -   イベントにタグとしてグループを追加。
    -   公開設定や編集権限などを管理。
    -   グループ作成者が全ての権限を持つ。
-   **自動保存:** 編集内容はバックグラウンドで定期的に自動保存。
-   **レスポンシブデザイン:** 様々な画面サイズに対応（Tailwind CSSで構築）。

## 技術スタック

-   **フレームワーク:** Next.js 14 (App Router)
-   **認証:** NextAuth.js
-   **データベースORM:** Prisma
-   **データベース:** SQLite
-   **スタイリング:** Tailwind CSS
-   **UI:** React
-   **言語:** TypeScript

## コアコンセプト

-   **イベント駆動:**
    -   すべての通信はイベントを介して行われる。
    -   例えば、メモの作成、メモの編集、メモの削除、グループの編集など。
-   **ポーリング:** 
    -   5秒毎に実行される。
    -   すべての通信はポーリングを通して行われる。
    -   クライアントはサーバーへイベントの配列を送信し、イベントの配列を受け取る。
-   **tick処理:** ポーリングによりサーバーから受け取ったイベントの配列を、それぞれのイベントの種類に応じて各コンポーネントに伝える。

## イベント
-   **形式**
    ```json
    {
        "event_id": "<32文字の大小英数字 (0~9, a~z, A~Z)>",
        "auther_id": "<google auther_id>",
        "sign": "<google session_id (クライアントからサーバーへ送信するときのみ)>",
        "created_at": "<unix timestamp in seconds>",
        "tags": {
            "event": ["<event>"],
        },
        "kinds": "<kind (number list)>",
        "content": "<content data>",
    }
    ```

## コード品質と哲学

このプロジェクトは、Next.js (App Router) と TypeScript を使用する際に以下の原則を遵守することで、保守可能でパフォーマンスが高く、型安全なコードを目指しています。

-   **React Server Components (RSC) の優先:** パフォーマンス向上のため（クライアントバンドルの削減、データ取得の近接化）、デフォルトでRSCを使用します。クライアントコンポーネント (`"use client"`) は、インタラクティビティが必要な場合（`useState`, `useEffect`のようなフック、イベントハンドラ）にのみ使用します。RSCの制限（ブラウザAPIなし、プロップはシリアライズ可能でなければならない）を理解します。
-   **戦略的なデータ取得:**
    -   **RSC:** `async/await` を使用してコンポーネント内で直接データを取得します。キャッシュと再検証のためにNext.jsの拡張`fetch`オプションを活用します。
    -   **クライアントコンポーネント:** クライアント側のフェッチ、キャッシュ、ミューテーションには、手動の`useEffect`フェッチよりも、SWRやTanStack Query (React Query) のようなライブラリを優先し、より良い状態管理、キャッシュ、開発者体験を実現します。
    -   **ミューテーション:** 可能な限りフォーム送信やサーバーミューテーションにはServer Actionsを使用し、手動でのAPIルート処理の必要性を減らします。
-   **効果的な状態管理:**
    -   ローカル状態 (`useState`, `useReducer`) から始めます。
    -   ゆっくり変化するグローバルUI状態にはReact Contextを使用し、過度なプロップのバケツリレーを避けます。
    -   Contextが扱いにくくなった場合、複雑なクライアント側状態には軽量な状態管理ライブラリ（例：Zustand, Jotai）を検討します。
    -   クライアント状態とサーバーキャッシュ状態（SWR/TanStack Queryによって管理される）を区別します。
-   **TypeScriptの厳格な適用:**
    -   アプリケーション全体で強力な型付けを強制します。`any`の使用を避けます。
    -   プロップ、APIレスポンス、データ構造に対して明確な`interface`または`type`定義を行います。
    -   再利用可能で型安全なコードのためにTypeScriptのユーティリティ型とジェネリクスを活用します。
    -   `tsconfig.json`で`strict`モードを有効にします。
-   **関数型プログラミングの影響:**
    -   状態更新にはイミュータビリティ（不変性）を優先します。
    -   可能な限り純粋関数を作成します。
    -   副作用を最小限に抑えます。必要な副作用は、多くの場合カスタムフックやイベントハンドラ内で明示的に管理し、複雑なロジックフローでの`useEffect`への依存を制限します。
-   **コンポーネント設計:**
    -   コンポーネントを、明確な責任を持つ小さく再利用可能な単位に分割します。
    -   複雑なロジックやステートフルな振る舞いをカスタムフック (`use...`) に抽出します。
    -   コンポーネントの合成を優先します。
-   **Next.jsの規約の活用:** App Routerのファイル規約 (`layout.tsx`, `page.tsx`, `loading.tsx`, `error.tsx`)、Route Handlers、および`next/image`や`next/dynamic`のような組み込み最適化を活用します。

## プロジェクト構造

## APIエンドポイント

-   `GET /api/main`
    -   イベントのリストを受信します。
    -   一般的にクライアントは５秒ごとにサーバーからイベントを受信します。
-   `POST /api/main`
    - イベントのリストを、jsonとしてパースできる形式にして送信します。
    -   一般的にクライアントは５秒ごとにサーバーへイベントを送信します。

## データモデル (Prisma)

```prisma
```

## サイトレイアウト
- **ヘッダー**
  - 左側: lkjsxcnext (このプロジェクト名)
  - 右側: Googleサインインボタン (またはアカウント名とサインアウトボタンを表示)
- **エクスプローラー**
  - 全グループの公開メモと自分の所属するグループのプライベートメモを表示
- **メインウィンドウ**
  - エディターモード: (自分自身が)変更した場合、送信キューに追加 (ポーリング)。
    - タイトルテキストボックス
    - コンテンツテキストボックス
    - 公開/非公開トグル
    - 削除ボタン
  - ビューワーモード: (他のユーザーが)変更した場合、受信キューに追加 (ポーリング)。
    - タイトルテキスト
    - コンテンツテキスト

### 環境変数

1.  プロジェクトのルートに `.env` ファイルを作成します。

2.  `.env` ファイルに必要な環境変数を入力します:

    ```dotenv
    # データベース接続文字列 (Prisma)
    DATABASE_URL="file:./dev.db"

    # NextAuth 設定
    # 強力なシークレットを生成: Linux/macOSでは `openssl rand -base64 32`
    NEXTAUTH_SECRET="YOUR_NEXTAUTH_SECRET"
    # 開発用のアプリケーションのベースURL
    NEXTAUTH_URL="http://localhost:3000" # 重要: デプロイ時には変更してください

    # Google OAuth 認証情報
    # Google Cloud Console -> APIとサービス -> 認証情報 -> 認証情報を作成 -> OAuthクライアントID から取得します
    # 承認済みのJavaScript生成元に http://localhost:3000 を含めるようにしてください
    # 承認済みのリダイレクトURIに http://localhost:3000/api/auth/callback/google を含めるようにしてください
    GOOGLE_CLIENT_ID="YOUR_GOOGLE_CLIENT_ID.apps.googleusercontent.com"
    GOOGLE_CLIENT_SECRET="YOUR_GOOGLE_CLIENT_SECRET"
    ```

## 既知の問題と将来の拡張機能

-   **UIフィードバック:** 保存、ポーリング更新、保存競合の処理などの非同期操作中の視覚的なフィードバックを改善します（例：さりげないローディングインジケーター、エラー/競合時のトースト通知）。
-   **リアルタイム性:** 特にコラボレーションシナリオにおいて、真に即時の更新のためにポーリングをWebSockets（例：Pusher, Socket.IO, Ably）に置き換えます。
-   **エディタ機能:** メモコンテンツにMarkdownサポートまたはよりリッチなテキストエディタを追加します。
-   **整理:** メモの整理を改善するために、フォルダ、タグ、またはカテゴリを実装します。
-   **検索:** メモ全体にわたる全文検索機能を追加します。
-   **エラー処理:** クライアント側とサーバー側のエラー処理と報告を強化します。

## コントリビューション

コントリビューションを歓迎します！潜在的な変更や機能について議論するためにissueを開いたり、プルリクエストを送信したりしてください。大きな変更の場合は、まずissueを開いてください。

*(オプション：コーディングスタイル、コミットメッセージのフォーマットなど、より具体的なコントリビューションガイドラインを追加してください。)*