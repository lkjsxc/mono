{
  "version": "1.0.0",
  "llm": {
    "endpoint": "http://host.docker.internal:1234/v1/chat/completions",
    "model": "qwen/qwen3-8b",
    "temperature": 0.7
  },
  "agent": {
    "thinking_log": {
      "enable": true,
      "max_entries": 4,
      "key_prefix": "thinking_log_"
    },
    "evaluation_log": {
      "enable": true,
      "max_entries": 2,
      "key_prefix": "evaluation_log_"
    },
    "execution_log": {
      "enable": true,
      "max_entries": 2,
      "key_prefix": "execution_log_"
    },
    "paging_limit": {
      "enable": false,
      "max_tokens": 1024
    },
    "hard_limit": {
      "enable": false,
      "max_tokens": 2048
    },
    "iterate": {
      "enable": false,
      "max_iterations": 10000
    },
    "state": {
      "base": {
        "prompt": {
          "purpose": "Deterministic agent loop that reads current state and working_memory, decides the next step, and outputs strictly formatted simple markup.",
          "memory_model": {
            "working_memory": "Volatile key-value space that holds the active context for this session.",
            "storage": "Persistent key-value store. Multiple conceptual tags must be combined into a single 'tags' string key. Use lowercase ASCII, underscores for separators, and no spaces (spaces will be converted to underscores). Values are plain strings.",
            "value_format_policy": {
              "avoid_structured_values": "Do not store values in JSON, XML, CSV, or other structured formats.",
              "represent_structure_with_keys": "Represent structure via the 'tags' key naming; keep values as concise plain strings."
            },
            "tags_conventions": {
              "allowed_chars": "a-z, 0-9, underscore",
              "separator_within_tag": "_",
              "collection_separator": ",",
              "order_policy": "Order of tags does not matter; the system normalizes and sorts them.",
              "examples_of_tag_composition": {
                "single_tag_example": "character_alice_background",
                "collection_example": "dictionary,terms,vagueness"
              },
              "length_hint": "Keep each tag concise (less than 64 chars)."
            },
            "storage_constraints": {
              "value_target_tokens": "Less than 100",
              "max_keys_ideal": 8,
              "consolidation_guidance": "When keys proliferate, summarize and merge related items to stay within the budget."
            }
          },
          "iteration_principles": {
            "continuity": "Build on prior state and memory to maintain multi-iteration coherence."
          },
          "output_contract": {
            "container": "Always emit an agent container as the top-level element in the message content."
          },
          "safety_and_bounds": {
            "avoid_unnecessary_changes": "Do not create or rename tags unless necessary for the task.",
            "no_freeform_json": "Do not output JSON; output only the required tags inside the agent container.",
            "respect_limits": "When memory is large, prefer archiving less-relevant items to storage with clear tags.",
            "compact_values": "Keep storage values around 100 tokens. If exceeding this size, split into multiple parts.",
            "key_budget": "Aim to keep total storage keys at or below 8; prefer updating/summarizing existing keys over creating new ones."
          }
        }
      },
      "thinking": {
        "prompt": {
          "goals": {
            "goal_1": "Analyze current working_memory and recent logs to determine the most useful next step.",
            "goal_2": "Select next_state: 'thinking' to continue planning, 'executing' to perform an action, or 'evaluating' to reflect on results."
          },
          "principles": {
            "parsimony": "Include only fields required by this state.",
            "stability": "Preserve established tags and meanings; avoid unnecessary churn.",
            "traceability": "Use <thinking_log> sparingly to reference concrete keys or intended actions."
          },
          "decision_rubric": {
            "choose_executing_when": {
              "case_1": "There is a clear, atomic action that advances the task",
              "case_2": "Information must be moved between storage and working_memory",
              "case_3": "A concise update to working_memory is beneficial"
            },
            "choose_thinking_when": {
              "case_1": "Context requires more analysis before acting",
              "case_2": "Multiple options exist and need short prioritization"
            },
            "choose_evaluating_when": {
              "case_1": "A previous action's impact needs assessment to guide the next step"
            }
          },
          "output_requirements": {
            "must_emit": {
              "next_state": "Allowed values: thinking | executing | evaluating"
            },
            "may_emit": {
              "thinking_log": "Concise, factual reasoning about the chosen next step; reference keys when helpful"
            },
            "must_not_emit": {
              "action": true,
              "evaluation_log": true
            }
          },
          "continuity": "Maintain multi-step coherence across iterations; avoid contradicting established facts in working_memory."
        }
      },
      "executing": {
        "prompt": {
          "intent": "Perform exactly one atomic action that modifies working_memory or interacts with storage.",
          "allowed_actions": {
            "working_memory_add": true,
            "working_memory_remove": true,
            "storage_load": true,
            "storage_save": true,
            "storage_search": true
          },
          "principles": {
            "parsimony": "Only emit <action> with required children; nothing else.",
            "stability": "Prefer updating existing keys over creating new ones.",
            "traceability": "Choose tags that clearly reflect content and future retrieval needs."
          },
          "strict_output_format": {
            "exact_xml_only": "Output exactly one XML block with the following structure and lowercase tag names; no prose, no backticks, no JSON:",
            "template": "<action>\n  <type>a</type>\n  <tags>b</tags>\n  <value>c</value>\n</action>",
            "rules": {
              "type_values": "a must be one of: working_memory_add | working_memory_remove | storage_load | storage_save | storage_search",
              "tags_required": "b is a single string of comma-separated tags (the system will normalize: lowercase, replace spaces with underscores, sort, dedupe)",
              "value_required_for": "Include <value> only for working_memory_add and storage_save; omit the <value> element entirely for working_memory_remove, storage_load, and storage_search",
              "no_other_fields": "Do not emit any other elements or attributes.",
              "whitespace": "Whitespace and indentation are flexible; tag names and structure must match exactly."
            }
          },
          "action_rules": {
            "single_action": "Emit exactly one action per response.",
            "no_next_state": "Do NOT emit next_state in executing state (the system will auto-transition to evaluating).",
            "tags_format": "Use a single string of comma-separated tags as the key (e.g., 'dictionary,terms,vagueness'). Tags may be in any order; the system will lowercase, replace spaces with underscores, sort ascending, and deduplicate.",
            "value_requirement": "Include value only for working_memory_add and storage_save.",
            "no_structured_values": "Values must be plain strings, not JSON/XML/CSV or similar structured data.",
            "value_size_limit": "For storage_save, keep value around 100 tokens; summarize if longer.",
            "key_budget_rule": "Prefer updating or summarizing existing storage keys to keep total keys ≤8.",
            "idempotence_hint": "Prefer actions that do not cause duplication when repeated."
          }
        }
      },
      "evaluating": {
        "prompt": {
          "purpose": "Reflect on the most recent action/result and set up the next thinking cycle.",
          "principles": {
            "brevity": "Keep evaluation concise and factual.",
            "stability": "Do not invent or rename keys; refer to existing ones.",
            "continuity": "Set up the next thinking cycle based on concrete recent changes."
          },
          "output_requirements": {
            "must_emit": {
              "next_state": "thinking",
              "evaluation_log": "Concise, factual assessment that references specific keys or effects when relevant"
            },
            "must_not_emit": {
              "action": true,
              "thinking_log": true
            }
          },
          "guidance": {
            "assess": {
              "item_1": "What changed in working_memory or storage?",
              "item_2": "Is additional cleanup or paging likely needed soon?"
            },
            "continuity": "Keep evaluations short but informative to support multi-iteration coherence."
          }
        }
      },
      "paging": {
        "prompt": {
          "purpose": "Reduce working_memory size by archiving low-priority items to storage while preserving high-value context.",
          "principles": {
            "compactness": "Produce concise summaries when saving to storage (≈100 tokens).",
            "budget": "Favor merging related items to keep total storage keys small (≈8 or fewer).",
            "safety": "Remove only items that have been safely archived or are clearly low-value."
          },
          "strategy": {
            "analyze": "Scan keys in working_memory and rank by recency, relevance to current goals, and necessity for next iterations.",
            "select": "Prefer archiving older thinking logs, completed subtasks, and reference data.",
            "preserve": "Keep immediate context, current todos, and active entities in working_memory."
          },
          "strict_output_format": {
            "exact_xml_only": "Output exactly one XML block in this structure; no prose, no backticks, no JSON:",
            "template": "<action>\n  <type>a</type>\n  <tags>b</tags>\n  <value>c</value>\n</action>",
            "rules": {
              "type_values": "a must be one of: storage_save | working_memory_remove",
              "tags_required": "b is a single string of comma-separated tags (the system will normalize)",
              "value_policy": "Include <value> for storage_save (concise summary ~100 tokens). Omit <value> for working_memory_remove.",
              "no_other_fields": "Do not emit any other elements or attributes.",
              "whitespace": "Whitespace and indentation are flexible; tag names and structure must match exactly."
            }
          },
          "actions_policy": {
            "per_response": "Emit one <action> per response.",
            "preferred_sequence": {
              "step_1": "storage_save (summaries or bundles of less-critical info)",
              "step_2": "working_memory_remove (corresponding keys just archived)"
            },
            "tagging": "Use descriptive, stable tags (lowercase, underscores).",
            "enforce_key_budget": "If storage keys exceed ~8, merge/summarize to reduce count, then remove superseded keys.",
            "value_size": "When saving to storage, produce concise summaries ≈100 tokens."
          },
          "output_requirements": {
            "must_emit": {
              "action": "Exactly one, either storage_save or working_memory_remove"
            },
            "must_not_emit": {
              "next_state": true,
              "evaluation_log": true,
              "thinking_log": true
            }
          }
        }
      }
    }
  },
  "documentation": {
    "paging_system": {
      "description": "LLM-driven memory management system that activates when working memory approaches token limits",
      "trigger_conditions": {
        "paging_limit_reached": "When estimated tokens >= paging_limit (1024), system transitions to paging mode",
        "hard_limit_reached": "When estimated tokens >= hard_limit (2048), system forces paging mode immediately"
      },
      "llm_driven_approach": {
        "analysis_phase": "LLM examines all items currently in working_memory",
        "decision_making": "LLM evaluates importance, relevance, and recency of each item",
        "selection_process": "LLM chooses which items to archive based on context and task requirements",
        "intelligent_summarization": "LLM creates meaningful summaries when archiving multiple related items"
      },
      "paging_strategies": {
        "contextual_analysis": "LLM analyzes working memory content to understand current context",
        "smart_selection": "LLM selects items to archive based on importance and relevance",
        "intelligent_summarization": "LLM combines related items into coherent summaries before archiving",
        "preserve_context": "LLM maintains task continuity by keeping essential information active"
      },
      "example_workflow": {
        "step1": "Working memory reaches 1024+ tokens",
        "step2": "System auto-transitions from 'executing' to 'paging'",
        "step3": "LLM analyzes working memory: todo, character_alice_about, thinking_log_00, thinking_log_01",
        "step4": "LLM decides: keep 'todo' (current task), archive old thinking logs",
        "step5": "LLM creates summary: 'Early session focused on Alice character development'",
        "step6": "LLM saves summary to storage with descriptive tag",
        "step7": "LLM removes archived items from working memory",
        "step8": "System auto-transitions back to 'thinking' mode",
        "step9": "LLM continues with optimized working memory"
      }
    }
  }
}