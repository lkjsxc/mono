{
  "version": "0003",
  "llm": {
    "endpoint": "http://host.docker.internal:1234/v1/chat/completions",
    "model": "qwen/qwen3-8b",
    "temperature": 0.7
  },
  "agent": {
    "iteration_limit": {
      "enable": true,
      "value": 10000
    },
    "state": {
      "base": {
        "prompt": {
          "purpose": "Deterministic multi-step loop. Read current state + working_memory, decide next step, and emit strictly formatted XML.",
          "memory_model": {
            "working_memory": "Volatile key-value space for active context.",
            "storage": "Persistent key-value store with unlimited capacity. Combine conceptual tags in a single 'tags' string key; lowercase ASCII; underscores; no spaces.",
            "value_format_policy": {
              "avoid_structured_values": "No JSON/XML/CSV in values; plain strings only.",
              "represent_structure_with_keys": "Represent structure via tags, not values."
            },
            "tags_conventions": {
              "allowed_chars": "a-z, 0-9, underscore",
              "separator_within_tag": "_",
              "collection_separator": ",",
              "order_policy": "Order of tags is irrelevant.",
              "examples_of_tag_composition": {
                "single_tag_example": "character_alice_background",
                "collection_example": "dictionary,terms,vagueness"
              },
              "length_hint": "Keep each tag < 64 chars."
            },
            "storage_usage_policy": {
              "capacity": "Unlimited.",
              "value_target_tokens": "≈100 tokens per key; split if longer.",
              "granularity": "Prefer small, focused values with descriptive tags.",
              "housekeeping": "Occasionally consolidate for readability."
            }
          },
          "iteration_principles": {
            "continuity": "Build on prior state + memory for coherence.",
            "minimality": "Keep outputs short and unambiguous for Qwen3-8B."
          },
          "output_contract": {
            "container": "Always emit <agent> as top-level with EXACTLY one <next_state> and EXACTLY one <action> using the commanding schema.",
            "schema_template": "<agent>\n  <next_state>STATE</next_state>\n  <action>\n    <type>TYPE</type>\n    <tags>TAGS</tags>\n    <value>VALUE</value>\n  </action>\n</agent>",
            "schema_rules": {
              "allowed_states": "thinking | commanding | evaluating | paging",
              "allowed_types": "working_memory_add | working_memory_remove | storage_load | storage_save | storage_search",
              "tags_required": "Comma-separated tags string.",
              "value_required_for": "Include <value> only for working_memory_add and storage_save; otherwise include empty element <value></value>."
            }
          },
          "safety_and_bounds": {
            "avoid_unnecessary_changes": "Do not create/rename tags unless needed.",
            "no_freeform_json": "Output only XML inside <agent>.",
            "respect_limits": "When working_memory grows, archive to storage with clear tags.",
            "compact_values": "Aim for ≈60–120 tokens in values.",
            "storage_capacity": "Unlimited; save liberally for traceability."
          },
          "quality": {
            "clarity": "Direct, specific, minimal verbosity.",
            "traceability": "Thinking/evaluating must leave concise traces in working_memory.",
            "default_flow": "thinking → commanding → evaluating → (paging as needed) → thinking."
          }
        }
      },
      "thinking": {
        "prompt": {
          "goals": {
            "g1": "Analyze working_memory + logs; pick the most useful next atomic action.",
            "g2": "Record the reasoning that leads to that action into working_memory."
          },
          "principles": {
            "parsimony": "Emit only required fields.",
            "stability": "Preserve existing tags.",
            "traceability": "Always log rationale."
          },
          "decision_rubric": {
            "choose_commanding_when": "A clear atomic action is identified or info needs to move between storage and working_memory.",
            "choose_paging_when": "Working_memory is crowded or token budget is tight."
          },
          "strict_output_format": {
            "template": "<agent>\n  <next_state>STATE</next_state>\n  <action>\n    <type>working_memory_add</type>\n    <tags>thinking_notes</tags>\n    <value>Concise rationale for the next atomic action, key options considered, and chosen action summary.</value>\n  </action>\n</agent>",
            "rules": {
              "state_policy": "STATE must be 'commanding' by default, or 'paging' if cleanup is necessary before action.",
              "value_policy": "Keep to ≈60–120 tokens; no lists/tables/JSON."
            }
          }
        }
      },
      "commanding": {
        "prompt": {
          "intent": "Perform exactly one atomic action that modifies working_memory or interacts with storage.",
          "allowed_actions": {
            "working_memory_add": true,
            "working_memory_remove": true,
            "storage_load": true,
            "storage_save": true,
            "storage_search": true
          },
          "principles": {
            "parsimony": "Emit only <next_state> and one <action>.",
            "stability": "Prefer updating existing keys.",
            "traceability": "Choose informative tags; rely on prior thinking_notes.",
            "storage_first": "Favor persisting to storage if in doubt."
          },
          "strict_output_format": {
            "template": "<agent>\n  <next_state>evaluating</next_state>\n  <action>\n    <type>TYPE</type>\n    <tags>TAGS</tags>\n    <value>VALUE</value>\n  </action>\n</agent>",
            "rules": {
              "next_state_values": "Must always be 'evaluating'.",
              "type_values": "TYPE ∈ {working_memory_add, working_memory_remove, storage_load, storage_save, storage_search}.",
              "tags_required": "TAGS is a comma-separated tags string.",
              "value_required_for": "Include VALUE only for working_memory_add or storage_save; otherwise output an empty VALUE element."
            }
          },
          "action_rules": {
            "single_action": "Emit exactly one action.",
            "no_structured_values": "Values are plain strings; no JSON/XML.",
            "value_size_limit": "For storage_save, ≈100 tokens.",
            "thinking_trace_requirement": "If the chosen TYPE is not working_memory_add, ensure the prior state logged rationale in 'thinking_notes'."
          }
        }
      },
      "evaluating": {
        "prompt": {
          "purpose": "Briefly reflect on the most recent action’s effect and prepare for the next thinking cycle.",
          "principles": {
            "brevity": "Concise and factual.",
            "stability": "Do not invent/rename keys.",
            "continuity": "Support the next reasoning step."
          },
          "strict_output_format": {
            "template": "<agent>\n  <next_state>thinking</next_state>\n  <action>\n    <type>working_memory_add</type>\n    <tags>evaluation_notes</tags>\n    <value>What changed, immediate outcome, any follow-ups or cleanup needed.</value>\n  </action>\n</agent>",
            "rules": {
              "next_state_values": "Must always be 'thinking'.",
              "value_policy": "Keep to ≈40–80 tokens."
            }
          },
          "guidance": {
            "assess": {
              "item_1": "What changed in working_memory or storage?",
              "item_2": "Is cleanup/paging needed soon?"
            }
          }
        }
      },
      "paging": {
        "prompt": {
          "purpose": "Reduce working_memory by archiving low-priority items to storage while preserving high-value context.",
          "principles": {
            "compactness": "Summarize when saving (≈100 tokens).",
            "declutter": "Move detail out; storage is unlimited.",
            "safety": "Only remove what was archived or is low value."
          },
          "strategy": {
            "analyze": "Rank working_memory by recency/relevance.",
            "select": "Archive older thinking logs and completed subtasks.",
            "preserve": "Keep immediate context and active todos."
          },
          "strict_output_format": {
            "template": "<agent>\n  <next_state>thinking</next_state>\n  <action>\n    <type>TYPE</type>\n    <tags>TAGS</tags>\n    <value>VALUE</value>\n  </action>\n</agent>",
            "rules": {
              "type_values": "TYPE must be storage_save or working_memory_remove.",
              "tags_required": "TAGS is a comma-separated tags string identifying what is archived or removed.",
              "value_policy": "Include VALUE only for storage_save (compact summary). For working_memory_remove, include empty VALUE."
            }
          },
          "actions_policy": {
            "per_response": "Emit exactly one action.",
            "preferred_sequence": "If multiple items: first storage_save (archive), then on the next turn working_memory_remove (cleanup)."
          }
        }
      }
    }
  }
}
