{
  "version": "1.0.0",
  "llm": {
    "endpoint": "http://host.docker.internal:1234/v1/chat/completions",
    "model": "qwen/qwen3-8b",
    "temperature": 0.7
  },
  "agent": {
    "think_log": {
      "enable": true,
      "max_entries": 4,
      "key_prefix": "think_log_"
    },
    "evaluation_log": {
      "enable": true,
      "max_entries": 1,
      "key_prefix": "evaluation_log_"
    },
    "command_log": {
      "enable": true,
      "max_entries": 1,
      "key_prefix": "command_log_"
    },
    "paging_limit": {
      "enable": false,
      "max_tokens": 1024
    },
    "hard_limit": {
      "enable": false,
      "max_tokens": 2048
    },
    "iterate": {
      "enable": false,
      "max_iterations": 10000
    },
    "state": {
      "base": {
        "prompt": {
          "purpose": "Deterministic agent loop that reads current state and working_memory, decides the next step, and outputs strictly formatted simple markup.",
          "memory_model": {
            "working_memory": "Volatile key-value space that holds the active context for this session.",
            "storage": "Persistent key-value store with effectively unlimited capacity. Multiple conceptual tags must be combined into a single 'tags' string key. Use lowercase ASCII, underscores for separators, and no spaces (spaces will be converted to underscores). Values are plain strings. When in doubt, prefer saving rich, retrievable details to storage.",
            "value_format_policy": {
              "avoid_structured_values": "Do not store values in JSON, XML, CSV, or other structured formats.",
              "represent_structure_with_keys": "Represent structure via the 'tags' key naming; keep values as concise plain strings."
            },
            "tags_conventions": {
              "allowed_chars": "a-z, 0-9, underscore",
              "separator_within_tag": "_",
              "collection_separator": ",",
              "order_policy": "Order of tags does not matter; the system normalizes and sorts them.",
              "examples_of_tag_composition": {
                "single_tag_example": "character_alice_background",
                "collection_example": "dictionary,terms,vagueness"
              },
              "length_hint": "Keep each tag concise (less than 64 chars)."
            },
            "storage_usage_policy": {
              "capacity": "Effectively unlimited; create as many keys as helpful for retrieval and provenance.",
              "value_target_tokens": "Around 100 tokens per key; if longer, split across multiple keys instead of shrinking content.",
              "granularity": "Prefer small, focused values saved under descriptive, composable tags—it's fine to spread information across many keys.",
              "housekeeping": "Occasionally consolidate for readability, not due to capacity limits."
            }
          },
          "iteration_principles": {
            "continuity": "Build on prior state and memory to maintain multi-iteration coherence."
          },
          "output_contract": {
            "container": "Always emit an agent container as the top-level element in the message content."
          },
          "safety_and_bounds": {
            "avoid_unnecessary_changes": "Do not create or rename tags unless necessary for the task.",
            "no_freeform_json": "Do not output JSON; output only the required tags inside the agent container.",
            "respect_limits": "When memory is large, prefer archiving less-relevant items to storage with clear tags.",
            "compact_values": "Keep storage values around 100 tokens. If exceeding this size, split into multiple parts.",
            "storage_capacity": "Storage capacity is unlimited; favor liberal saving to storage for traceability and retrieval."
          }
        }
      },
      "thinking": {
        "prompt": {
          "goals": {
            "goal_1": "Analyze current working_memory and recent logs to determine the most useful next step.",
            "goal_2": "Select next_state: 'thinking' to continue planning, 'commanding' to perform an action, or 'evaluating' to reflect on results."
          },
          "principles": {
            "parsimony": "Include only fields required by this state.",
            "stability": "Preserve established tags and meanings; avoid unnecessary churn.",
            "traceability": "Use <think_log> sparingly to reference concrete keys or intended actions."
          },
          "decision_rubric": {
            "choose_commanding_when": {
              "case_1": "There is a clear, atomic action that advances the task",
              "case_2": "Information must be moved between storage and working_memory",
              "case_3": "A concise update to working_memory is beneficial"
            },
            "choose_thinking_when": {
              "case_1": "Context requires more analysis before acting",
              "case_2": "Multiple options exist and need short prioritization"
            },
            "choose_evaluating_when": {
              "case_1": "A previous action's impact needs assessment to guide the next step"
            }
          },
          "output_requirements": {
            "must_emit": {
              "next_state": "Allowed values: thinking | commanding | evaluating"
            },
            "may_emit": {
              "think_log": "Concise, factual reasoning about the chosen next step; reference keys when helpful"
            },
            "must_not_emit": {
              "action": true,
              "evaluation_log": true
            }
          },
          "continuity": "Maintain multi-step coherence across iterations; avoid contradicting established facts in working_memory."
        }
      },
      "commanding": {
        "prompt": {
          "intent": "Perform exactly one atomic action that modifies working_memory or interacts with storage.",
          "allowed_actions": {
            "working_memory_add": true,
            "working_memory_remove": true,
            "storage_load": true,
            "storage_save": true,
            "storage_search": true
          },
          "principles": {
            "parsimony": "Only emit <action> with required children; nothing else.",
            "stability": "Prefer updating existing keys over creating new ones.",
            "traceability": "Choose tags that clearly reflect content and future retrieval needs.",
            "storage_first": "When in doubt, persist useful details to storage. Storage capacity is unlimited, so don't hesitate to create new keys for clarity and recall."
          },
          "strict_output_format": {
            "exact_xml_only": "Output exactly one XML block with the following structure and lowercase tag names; no prose, no backticks, no JSON:",
            "template": "<action>\n  <type>a</type>\n  <tags>b</tags>\n  <value>c</value>\n</action>",
            "rules": {
              "type_values": "a must be one of: working_memory_add | working_memory_remove | storage_load | storage_save | storage_search",
              "tags_required": "b is a single string of comma-separated tags (the system will normalize: lowercase, replace spaces with underscores, sort, dedupe)",
              "value_required_for": "Include <value> only for working_memory_add and storage_save; omit the <value> element entirely for working_memory_remove, storage_load, and storage_search",
              "no_other_fields": "Do not emit any other elements or attributes.",
              "whitespace": "Whitespace and indentation are flexible; tag names and structure must match exactly."
            }
          },
          "action_rules": {
            "single_action": "Emit exactly one action per response.",
            "no_next_state": "Do NOT emit next_state in commanding state (the system will auto-transition to evaluating).",
            "tags_format": "Use a single string of comma-separated tags as the key (e.g., 'dictionary,terms,vagueness'). Tags may be in any order; the system will lowercase, replace spaces with underscores, sort ascending, and deduplicate.",
            "value_requirement": "Include value only for working_memory_add and storage_save.",
            "no_structured_values": "Values must be plain strings, not JSON/XML/CSV or similar structured data.",
            "value_size_limit": "For storage_save, keep value around 100 tokens; summarize if longer.",
            "unlimited_capacity": "Storage capacity is unlimited—feel free to create new, well-tagged keys to maximize retrieval quality.",
            "idempotence_hint": "Prefer actions that do not cause duplication when repeated."
          }
        }
      },
      "evaluating": {
        "prompt": {
          "purpose": "Reflect on the most recent action/result and set up the next thinking cycle.",
          "principles": {
            "brevity": "Keep evaluation concise and factual.",
            "stability": "Do not invent or rename keys; refer to existing ones.",
            "continuity": "Set up the next thinking cycle based on concrete recent changes."
          },
          "output_requirements": {
            "must_emit": {
              "next_state": "thinking",
              "evaluation_log": "Concise, factual assessment that references specific keys or effects when relevant"
            },
            "must_not_emit": {
              "action": true,
              "think_log": true
            }
          },
          "guidance": {
            "assess": {
              "item_1": "What changed in working_memory or storage?",
              "item_2": "Is additional cleanup or paging likely needed soon?"
            },
            "continuity": "Keep evaluations short but informative to support multi-iteration coherence."
          }
        }
      },
      "paging": {
        "prompt": {
          "purpose": "Reduce working_memory size by archiving low-priority items to storage while preserving high-value context. Storage capacity is unlimited; paging exists to declutter working_memory tokens, not because storage is scarce.",
          "principles": {
            "compactness": "Produce concise summaries when saving to storage (≈100 tokens).",
            "declutter": "Use paging to move detail out of working_memory liberally; storage has no practical limit.",
            "safety": "Remove only items that have been safely archived or are clearly low-value."
          },
          "strategy": {
            "analyze": "Scan keys in working_memory and rank by recency, relevance to current goals, and necessity for next iterations.",
            "select": "Prefer archiving older thinking logs, completed subtasks, and reference data.",
            "preserve": "Keep immediate context, current todos, and active entities in working_memory."
          },
          "strict_output_format": {
            "exact_xml_only": "Output exactly one XML block in this structure; no prose, no backticks, no JSON:",
            "template": "<action>\n  <type>a</type>\n  <tags>b</tags>\n  <value>c</value>\n</action>",
            "rules": {
              "type_values": "a must be one of: storage_save | working_memory_remove",
              "tags_required": "b is a single string of comma-separated tags (the system will normalize)",
              "value_policy": "Include <value> for storage_save (concise summary ~100 tokens). Omit <value> for working_memory_remove.",
              "no_other_fields": "Do not emit any other elements or attributes.",
              "whitespace": "Whitespace and indentation are flexible; tag names and structure must match exactly."
            }
          },
          "actions_policy": {
            "per_response": "Emit one <action> per response.",
            "preferred_sequence": {
              "step_1": "storage_save (summaries or bundles of less-critical info)",
              "step_2": "working_memory_remove (corresponding keys just archived)"
            },
            "tagging": "Use descriptive, stable tags (lowercase, underscores).",
            "unlimited_capacity": "No key-count budget—feel free to create more keys for clarity. Consolidate only for readability or navigation, not capacity.",
            "value_size": "When saving to storage, produce concise summaries ≈100 tokens."
          },
          "output_requirements": {
            "must_emit": {
              "action": "Exactly one, either storage_save or working_memory_remove"
            },
            "must_not_emit": {
              "next_state": true,
              "evaluation_log": true,
              "think_log": true
            }
          }
        }
      }
    }
  },
  "documentation": {
    "paging_system": {
  "description": "LLM-driven memory management system that activates when working memory approaches token limits. Storage capacity is unlimited; paging is about managing working_memory tokens, not storage size.",
      "trigger_conditions": {
        "paging_limit_reached": "When estimated tokens >= paging_limit (1024), system transitions to paging mode",
        "hard_limit_reached": "When estimated tokens >= hard_limit (2048), system forces paging mode immediately"
      },
      "llm_driven_approach": {
        "analysis_phase": "LLM examines all items currently in working_memory",
        "decision_making": "LLM evaluates importance, relevance, and recency of each item",
        "selection_process": "LLM chooses which items to archive based on context and task requirements",
        "intelligent_summarization": "LLM creates meaningful summaries when archiving multiple related items"
      },
      "paging_strategies": {
        "contextual_analysis": "LLM analyzes working memory content to understand current context",
        "smart_selection": "LLM selects items to archive based on importance and relevance",
        "intelligent_summarization": "LLM combines related items into coherent summaries before archiving",
        "preserve_context": "LLM maintains task continuity by keeping essential information active"
      },
      "example_workflow": {
        "step1": "Working memory reaches 1024+ tokens",
        "step2": "System auto-transitions from 'commanding' to 'paging'",
        "step3": "LLM analyzes working memory: todo, character_alice_about, think_log_00, think_log_01",
        "step4": "LLM decides: keep 'todo' (current task), archive old thinking logs",
        "step5": "LLM creates summary: 'Early session focused on Alice character development'",
        "step6": "LLM saves summary to storage with descriptive tag",
        "step7": "LLM removes archived items from working memory",
        "step8": "System auto-transitions back to 'thinking' mode",
        "step9": "LLM continues with optimized working memory"
      }
    }
  }
}